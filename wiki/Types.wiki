#summary A summary of all Types implemented by Flaka
#labels Featured


<wiki:toc max_depth="1" />

= test =

A general test condition suporting the *Flaka* test expression language. This type can be used like any other condition type in a [Tasks#condition condition].

== Attribute ==
 * test<br/> The test condition

== Example ==

A condition setting property dir.exists if a relative folder named src exists.

{{{
 <condition property="dir.exists">
    <c:test test="-d src" />
 </condition>
}}}

== Reference ==
 * Implementation: {{ViewCVS|1=net/haefelingerit/Test.java}}
 * Javadoc: {{Javadoc|1=net/haefelingerit/Test.html}}

= dependency-selector =

Implements a {{AntRefType|1=selectors.html|2=Ant selector type}} to be used to restrict a fileset. The selection is done in relation to a set of dependencies. A file is selected if and only if the file's basename matches the basename of a dependency. The content, date, modification time and other attributes are not taken into account - only the name of the file matters.

In order to use this selector, a reference holding a set of dependency objects must exist. Such a set is best created within the project by using task [Tasks#getdeps getdeps] which uses the string deps.object for a later referencing. To use a different reference, use attribute refid or ref (notice that the current implementation expects to locate an object of type net.haefelingerit.flaka.dep.Dependency[]). If the reference being used does not hold a set of dependencies or if the set is empty, then no file is selected (cause no file name can match the name of a non existing dependency).

To invert the sense of matching use boolean attribute invert. When enabled, this attribute will select any file in the fileset for which no matching dependency basename could be found.

There are cases where a finer grained selection is required. A typical example is a selection based on the dependency's scope. The following example, will select each file having the same artefact name as a dependency but only if such a dependency would be in scope compile:

{{{
 <fileset ..>
   <c:dependency-selector scope="compile" />
 </fileset>
}}}

In addition to scope other dependency attributes like version, groupId et cetera can be used for fine-graining the selection. The following match attributes are available (see section Attribute for an explanation):
 * scope
 * alias, name 
 * basename
 * groupid, group, groupname
 * type
 * path
 * version 

If multiple match attributes are given, then they are anded. To implement a or selection, use the {{AntRefType|1=selectors.html#orselect|2=standard Ant or container}} like shown in the following example:

{{{
 <fileset ..>
   <or>
     <c:dependency-selector scope="compile" />
     <c:dependency-selector scope="provided" />
   </or>
 </fileset> 
}}}

This would select any dependency either in scope compile or scope provided. The example above can be 
shortened to 

{{{
 <fileset ..>
     <c:dependency-selector scope="/compile|provided/" />
 </fileset> 
}}}
 
Note the usage of `/`. This turns `compile|provided` into a true regular expression allowing
this kind of alternative selection. If a expression is under no circumstances to be interpreted as regular expression 
set either attribute glob to true or start and end the match pattern with character `%`. 

== Attribute ==
 * ref, refid [deps.object]<br/> Use this attribute to use a different reference holding all known dependencies. See task [Tasks#getdeps getdeps] for dependency retrieval.
 * invert [false]<br/> (boolean) Inverts the sense of matching, selects any file not matching a dependency's basename.
 * scope <br/>Matches the scope of a dependency as shown above
 * alias, name <br/>Matches the alias name of a dependency
 * basename <br/>Matches the dependency's basename (i.e. {artefactid}-{version}.{type})
 * groupid, group, groupname <br/>The group name (called groupid in Maven terminology)
 * type <br/>The type
 * path <br/>The complete path relative to a depot 
 * version <br/>The dependency's version
 * glob <br/> (boolean) When set to true interpret every matching string as pattern expression. Otherwise use leading and trailing character to specify the type of pattern (`/` => regular expression, `%` => pattern)

== Example ==

Assume that dependency 

{{{
  <c:dependency scope="runtime provided">
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.8</version>
  </c:dependency>
}}}

is given. Reference deps.object has been populated with this dependency, this does not necessarily mean that this dependency got downloaded. Furthermore assume that in folder libdir files log4j-1.2.8.jar and junit-3.8.1.jar exists. Then

{{{
 <copy todir="..">
  <fileset dir="libdir">
    <c:dependency-selector />
  <fileset />
 </copy>
}}}

would copy the file libdir/log4j-1.2.8.jar to it's new destination. Again, notice that a dependency does not have to be downloaded 
in order to get this working. The file libdir/log4j-1.2.8.jar is selected just because it happens that the basename is the same as the of the dependency given above. 

This example 

{{{
 <copy todir="..">
  <fileset dir="libdir">
    <c:dependency-selector scope=" *nti*" invert="true"/>
  <fileset />
 </copy>
}}}

would copy junit-3.8.1.jar cause the scope of log4j would match pattern *nti* and because attribute invert has been enabled.

== Reference ==
 * Implementation: {{ViewCVS|1=net/haefelingerit/dep/Select.java}}
 * Javadoc: {{Javadoc|1=net/haefelingerit/dep/Select.html}}

= filterset =

A filterset is a mapping between a token and it's replacement. Ant provides a simple filterset to add tokens and replacements, however there's a lack of just turning all project properties into tokens. This gap is filled by the version provided by *Flaka*. The version provided by *Flaka* behaves like the standard one and can therefore be used instead. To turn all properties into tokens, element properties must be used.

== Element ==
 * properties<br/> Create a token for each property in the current project. 

== Example ==

Create a reference named properties.filterset holding a filterset object. This object contains a list of tokens where each token was a property at the time when filterset was used. Properties added or removed later do not change the once created filterset.

{{{
  <c:filterset id="properties.filterset">
    <properties/>
  </c:filterset>
}}}

== Reference ==
 * Implementation: {{ViewCVS|1=net/haefelingerit/FilterSet.java}}
 * Javadoc: {{Javadoc|1=net/haefelingerit/FilterSet.html}}

= istext-selector =

A simple selector that selecting a file if it is a textual file rather than a binary one. To test whether text or binary,
the file is read and each character is tested. If a binary character is found, the selector does not select.

The test whether a character is text or binary depends in detail on the underlying implementation. However, the basic idea is
that the character to be tested must be printable. The underlying Java implementation tests the following Character classes:
 
 * Character.COMBINING_SPACING_MARK
 * Character.CONNECTOR_PUNCTUATION
 * Character.CURRENCY_SYMBOL
 * Character.DASH_PUNCTUATION
 * Character.DECIMAL_DIGIT_NUMBER
 * Character.ENCLOSING_MARK
 * Character.END_PUNCTUATION
 * Character.LOWERCASE_LETTER
 * Character.MATH_SYMBOL
 * Character.MODIFIER_SYMBOL
 * Character.NON_SPACING_MARK
 * Character.OTHER_LETTER
 * Character.OTHER_PUNCTUATION
 * Character.OTHER_SYMBOL
 * Character.SPACE_SEPARATOR
 * Character.START_PUNCTUATION
 * Character.TITLECASE_LETTER
 * Character.UPPERCASE_LETTER
 * Character.isWhitespace

== Attribute ==
 * limit<br/> The amount of characters to read for testing [-1]. If negative, all characters are read.
 * invert<br />Selects if the file is binary

== Example ==

The following example deletes all binary files from folder src.

{{{
 <delete>
  <fileset dir="src">
    <c:istext-selector invert="true" />
  </fileset>
 </delete>
}}}

== Reference ==
 * Implementation: {{ViewCVS|1=net/haefelingerit/IsText.java}}
 * Javadoc: {{Javadoc|1=net/haefelingerit/IsText.html}}

= identity-globmapper =

Ant provides so called mapper types used to translate (i.e. map) a filename in another one. A typical mapper is for example a mapper translating a *.java file in it's appropriate *.class file (by translating each '/' into a '.' and by changing the extension). See {{AntRefType|1=mapper.html|2=Ant's manual page}} for a list of mappers.

A useful mapper is {{AntRefType|1=mapper.html#glob|2= the glob mapper}} providing the basic functionality to change filenames on simple patterns. The following example would create a safe copy of all Java source files.

{{{
 <copy todir="backup">
  <fileset dir="src" >
    <glob from="*.java" to="*.java.save" />
  </fileset>
 </copy>
}}}

The question is what happens with all the other files that might exist in folder src? In the default implementation of Ant, mapper glob acts also as selector. This means that files other than those matching *.java are not copied. This might be useful in a case like above, but selecting files is the job of file selectors and not of mappers.

*Flaka* provides a pure glob mapper without any selection. This means that files matching a pattern are renamed while any other name will pass through:

{{{
 <copy todir="backup">
  <fileset dir="src" >
    <c:glob from="*.java" to="*.java.save" />
  </fileset>
 </copy>
}}}

This would copy all files in folder src and only rename *.java files. Yes, this example is not very striking! 

== Attribute ==
See type {{AntRefType|1=mapper.html#glob|2=glob}} for a list of supported attributes

== Element ==
See type {{AntRefType|1=mapper.html#glob|2=glob}} for a list of supported attributes

== Reference ==
 * Implementation: {{ViewCVS|1=net/haefelingerit/GlobMap.java}}
 * Javadoc: {{Javadoc|1=net/haefelingerit/GlobMap.html}}