#summary How to add Functions and Variables to EL
#labels Featured,Phase-Design

= Introduction =

* THIS IS WORK IN PROGESS AND NOT YET RELEASED*

Flaka's EL has been charged with a documented list of functions and values. So far it was not possible to extend this list.

= Details =

Flaka's EL has been charged with a documented list of functions and values. So far it was not possible to extend this list. Some effort has been put into changing this. There will be a new task `<el-load />` accepting
 * a Java class name
 * embedded Groovy source code

The Groovy code will be compiled into a Java class on the fly, i.e. at runtime. In either way, the Java class is expected to contain a arbitrary list of methods which are 
 * `static`
 * `public`
 * annotated by Annotation `it.haefelinger.flaka.el.Binding`

The number or arguments or return type does not matter. Especially is it possible to use variable-length arguments.

Let's start by adding a `sprintf()` function. Flaka contains already function `format()` which addresses the same purpose, namely generating a formated string. Furthermore, every `string` object contains a method `format` which would do the very same. Nevertheless, here is how an arbitrary Java class could look like

{{{
package my;
import it.haefelinger.flaka.el.Binding;

/**
 * A class containing functions to be imported into an EL context.
 */

public class ELBinding {
  @Binding
  static public String sprintf(String fmt, Object... args) {
    return String.format(fmt, args);
  }
}
}}}

Your Ant build script would then contain a task importing this class:

{{{
<project xmlns:fl="antlib:it.haefelinger.flaka" >
  ..
  <fl:el-load ns="my" type="file/class">
     ;;; The class containing my EL Bindings (see above).
     ;;; An arbitrary numer of classes may go here, one class per line.
     my.ELBinding
  </fl:el-load>
 ..
}}}

Here `format()` is be imported as `sprintf()` in namespace `my`. And off we go :
{{{
  <fl:echo>
  #{   my:sprintf("%s/%s",'foo','bar') }         ;; foo/bar
  </fl:echo>
}}}

This all works as expected if `my.ELBinding` made it's way into the JVM's classpath. Thus `my/ELBinding.java` must have been compiled in a previous step using a Java compiler. This compilation step can be omitted by adding a dependency on Groovy. In this case, just rename `my/ELBinding.java` into `my/ELBinding.groovy` and change `<fl:el-load />` into

{{{
  <fl:el-load ns="my" type="file/groovy">
     ;;; The Groovy file contains my EL Bindings (see above).
     ;;; An arbitrary numer of Groovy files may go here, one file per line.
     my/ELBinding.groovy
  </fl:el-load>
 ..
   <fl:echo>
   ;; This time sprintf() implemented in Groovy!
   #{   my:sprintf("%s/%s",'foo','bar') }         ;; foo/bar
  </fl:echo>
}}}

To make this work, `groovy-all.jar` must be added as runtime dependency. Due to it's size, `groovy-all.jar` has not been inlined into `ant-flaka.jar` as done with other jars Flaka depends on:

{{{
  > ant -lib ant-flaka.jar -lib groovy-all.jar ..
  [fl:echo] foo/bar
  ..
}}}


