#summary Expression Language Details
<wiki:toc />
= Introduction =

The [http://en.wikipedia.org/wiki/Unified_Expression_Language Java Unified Expression Language] [http://www.jcp.org/en/jsr/detail?id=245 (JSR-245)] is a special purpose programming (albeit not turing complete) language offering a simple way of accessing data objects. The language has its roots in Java web applications for embedding expressions into web pages. While the expression language is part of the JSP specification, it does in no way depend on the JSP specification. To the contrary, the language can be made available in a variety of contexts.

One such context is Ant scripting. Ant makes it difficult to access data objects. For example, there is no way of querying the underlying data object for the base folder (the folder containing the build script). All that Ant offers is the path name of this folder as _string_ object. This makes it for example rather cumbersome to report the last modification time of this folder. With the help of EL (sort for Unified Expression Language) this becomes an easy task:

{{{
<c:echo>
  ;; basedir is a standard Ant property 
  folder = ${basedir}

  ;; report last modification time (as Date object)
  last modified = #{ '${basedir}'.tofile.mtime }

  ;; dump the full name of this build file 
  ;; where 'ant.file' is a standard property
  this build file is #{property['ant.file'] }
</c:echo>
}}}

Being executed, this snippet produces something like 
{{{
[c:echo] folder = /projects/flaka/test
[c:echo] 
[c:echo] last modified = Mon Mar 09 13:52:29 CET 2009
[c:echo] 
[c:echo] this build file is /projects/flaka/test/tryme.xml
}}}
as output. Notice the usage of task [Tasks#echo echo]. When being tried with [http://ant.apache.org/manual/CoreTasks/echo.html Ant's standard echo task], a totally different output needs to be expected. Most important, EL references `#{..}` are not resolved but rather print as given.


= Disabling EL =

By default, _EL_ is enabled. _EL_ can be disabled by setting property `ant.el` to `false` (exactly as written). For example:
{{{
<!-- globally disable EL --->
<property name="ant.el" value="false" />
}}} 
If the property is not set, or set to a different value, then _EL_ is enabled.

= EL in Action =

The following example shows _EL_ in action.
{{{
<c:mset>
  root = '/'.tofile
  list = list()
</c:mset>
<c:for var="file" in=" root.list ">
  <c:when test=" file.isdir and not file.isread ">
    <c:mset>
      list = append(file,list)
    </c:mset>
  </c:when>
</c:for>
<c:echo>
  ;; how many unreadable directories ??
  There are #{size(list)} unreadable directories in #{root}.
  And here they are #{list}.
</c:echo>
}}}

Executed on MacOS 10.5.6 (aka "Leopard"), this gives:
{{{
[c:echo] There are 2 unreadable directories in /.
[c:echo] And here they are [/.Trashes, /.Spotlight-V100].
}}}

= EL's Availability =

_EL_ expressions can only be used in tasks which are _EL_ ready. This are:

 * [Tasks#set], [Tasks#mset]
 * [Tasks#properties]
 * [Tasks#when], [Tasks#unless]
 * [Tasks#for]
 * [Tasks#echo]

Further tasks to follow. It is further worked on to provide a task which enables _EL_ on a core level. This would allow to use _EL_ expressions similar to Ant property references `${..}`.

= EL Expression References =

Those not familiar with  [http://flaka.googlecode.com/files/jsp-2_1-fr-spec-el.pdf EL's specification], [http://en.wikipedia.org/wiki/JavaServer_Pages JSP] or [http://en.wikipedia.org/wiki/JavaServer_Faces JSF] may safely skip this section. 

For those familiar, the _term EL expression_ is used in a slightly different way in this documentation than in the specification. According to the specification, `#{..}` is an EL expression. 

Not so in this documentation. Here only the inner part, denoted by `..` while `#{ ..}` is considered a _reference to an EL expression_. A reference to an expression is used in contexts which are not evaluated by default. Take task [Tasks:#echo] as example. Clearly, when writing 
{{{
<c:echo>
 Hello world.
</c:echo>
}}}
we expect an output exactly as written. It would be nice to indicate however, that we want to have a part of the input evaluated as EL expression. This and only this is what `#{..}` is good for:
{{{
<c:echo>
 Hello #{ who }
</c:echo>
}}}

In other contexts, like in `<c:when test=" empty x " />`, a EL expression is expected anyway and it does not make the slightest sense to require the expression to be quoted like `#{ empty x }`.

Notice however, that in all contexts where a expression is expected, a expression reference can be used. This allows for advanced meta programming like shown in the following example:
{{{
<c:mset>
  metavar = 'i'
  ii = 0
</c:mset>
<c:for var=" #{metavar}#{metavar} " in=" list('a','b') " >
  <c:set var=" #{metavar}#{metavar} " value=" #{metavar}#{metavar} + 1 " />
<c:/for>
<c:echo>
  The value of 'ii' is #{ ii }
  ;; the value of 'ii' will be 2
<c:/echo>
}}}
 
= Basics =

The gory details of _EL_ are laid out in  the [http://flaka.googlecode.com/files/jsp-2_1-fr-spec-el.pdf the official JSR 245 specification] and are not repeated here. In short however, _EL_ let's you formulate [http://en.wikipedia.org/wiki/Expression_(programming) programming expressions] like 
{{{
  7 * (5.0+x) >= 0        ;; 1
  a and not (b || false)  ;; 2
  empty x ? 'foo' : x[0]  ;; 3
}}}
The expression in line (1) is a algebraic while (2) contains a boolean expression. The result of (1) depends on the resolution of variable `x` and similar does (2) on `a` and `b`.

= Data Types =
_EL_'s data types are integral and floating point numbers, strings, boolean and type `null`. Example data values of each type, except type `null`, are given above (1-3). Type `null` has once instance value also named `null`. While `null` can't be used to formulate an expression, it is important to understand that the result of evaluating an expression can be `null`. For example, the evaluation of a variable named `x` is the data object associated with that name. If no data is associcated however (i.e. if `x` is undefined), then `x` evaluates to `null`.

= Operators =
Four _operators_ are defined in _EL_:
 # `empty` checks whether a variable is empty or not and returns either `true` or `false`. It is important to understand that `null` is considered empty.
 #  condition operator `c ? a : b` evaluates `c` in a boolean context and returns the evaluation of expression `a` if `c` evaluates to `true`; otherwise `eval(b)` will be the result of this operator.
 # `.` and ;
 # `[]` are property operators described in [#Properties Properties] below.

= Properties =

Every data object in _EL_ may have properties associated. Which properties are available has not been standardized in the [http://flaka.googlecode.com/files/jsp-2_1-fr-spec-el.pdf specification]. In fact, this depends heavily on the underlying implementation and usage domain. What _EL_ specifies however, is how to query a property:
{{{
a.b.c
}}}
This expression can be translated into pseudo code as
{{{
 (property 'c' (property 'b' (eval a)))
}}}
which means that first variable `a` is evaluted, then property `b` is looked up on the evaluation result (giving a new evaluation result) and finally `c` is looked up giving the final result. 

Perhaps the most important point to notice is looking up a property on `null` is not an error but perfectly legal. No exception gets raised and no warning message generated. In fact, the result of such a operation is just `null` again.

From a practial point a question might be asked how to query a property which happens to contain the dot (`.`) character. In `a.b.c` example shown above, how would we lookup property `b.c` on `a`? Operator `[]` comes to rescue:
{{{
 a['b']        => a.b
 (a['b'])['c'] => a.b.c
 a['b']['c']   => a.b.c
 a[b]          => can't be expressed using '.'
 a[b.c]        => neither this ..
 a['b.c']      => query property 'b.c' on a 
}}}

So far, properties don't seem of any good use. The picture changes perhaps with this example:
{{{
 'abc'.toupper           => 'ABC'
 'abc'.length*4          => 12
 'abc'['tofile'].mkdir   => true/false
}}}
The last example demonstrates that there might also be [http://en.wikipedia.org/wiki/Side_effect_(computer_science) side effects] querying a property. In the example above, which is specific for Flaka, a directory `abc` gets created and the whole expression evaluates to `true` if the directory could get created and `false` otherwise.

= Implicit Objects =

Properties are good to query the state or features of data objects. The question is however how do we a data object to query in the first place? To start with something, _EL_ allows the implementation to provide _implicit_ objects and [#Functions]. 

The following implicit objects are defined by Flaka:
  * *project* Ant's underlying project object. It can be used to query the default target, base folder and other things. If you want to query properties, references, targets, tasks, taskdefs, macrodefs, filters etc., use appropriate implicit object instead.
  * *property* Use this object to query project properties.
  * *var* A object containing all project references. 
  * *reference* Same as *var*
  * *target* Use this object to query a target
  * *taskdef* Query taskdefs
  * *macrodefs* Macros
  * *tasks*  Either taskdef or macrodef. Macros are specialized task and thus same the same namespace.
  * *filter*  A object containing all filters defined in this project.

Assume for example that a property `foo` has been defined like 
{{{
<!-- standard Ant -->
<property name="foo" value="bar" />
}}}
Then `property.foo` or `property['foo']` or even `project.properties.foo` would evaluate to string `bar`. 

= Functions =

_EL_ also allows the implementation to provide top level functions. The following sections describe functions provided by Flaka.

|| Function || Type || Meaning ||
|| `size(object)`   || int  || Returns the object's size. The size of the object is given by the number of entities it contains. This is 0 (zero) for all primitive types. Otherwise the size is determined by an underlying `size()` method or `size` or `length` attribute of the object in question. || 
|| isnil(object)    || bool || Evaluates to `true` if object is the `nil` entity; otherwise `false`. This function can be used to check whether a reference (var) or property exists. Operator `empty` can't be used for this task, cause `empty` returns `true` if either not existing or if literatly _empty_ (for example the empty string). ||

= String Properties =

= File Properties =

Files and folders is Ant's bread and butter. A couple of properties are defined on file objects to simplify scripting (see below). Most important is however how to _get_ a file object in the first place. This is most easily done by using string property `tofile`:
{{{
  'myfolder'.tofile.isdir 
}}}
In this example of an EL expression, string `myfolder` is converted in a File object using property `tofile`. In addition, the so created object is checked whether it is a folder or not.

The following _properties_ are defined on File objects:
|| Property || Type || Meaning ||
|| `parent` || File || parent of file or folder as file object ||
|| `toabs`|| File || file or folder as absolute file object ||
|| `exists` || bool || check whether file or folder exists ||
|| `isfile` || bool || check whether a file ||
|| `isdir`  || bool || check whether a folder (directory) ||
|| `ishidden` || bool || check whether a hidden file or folder ||
|| `isread` || bool || check whether a file or folder is readable ||
|| `iswrite` || bool || check whether a file or folder is writable ||
|| `size`   || int  || number of bytes in a (existing) file; 0 otherwise||
|| `length` || int  || same as `size` ||
|| `mtime`  || Date || last modification date  ||
|| `list`   || File[] || array of files in folder ; otherwise `null` ||
|| `tostr` || String || file name as string object ||
|| `touri`    || URI  || file as URI object ||
|| `tourl`    || URL  || file as URL object ||
|| `delete` || bool || deletes the file or folder (true); false otherwise ||
|| `mkdir`  || bool || creates the folder (and intermediate) folders (true); false otherwise ||

When evaluating a condition to a bool value, a File object is checked for existence. For example, the following condition evaluates always to `true`:

{{{
 <c:set  var="f" value="'${ant.file}'.tofile " />
 <c:when test=" f " /> -- evaluates to 'true'; is same as
 <c:when test=" f.exists " />  
}}}




= Example =

The following larger example shows EL usage examples. Before starting, we define a couple of entities:
{{{
  <property name="name" value="PROPERTY name" />
  <c:set var="name" value=" REFERENCE name" />

  <target name="name" description="TARGET name" />

  <macrodef name="name1" description="NAME1 macro>
   <sequential />
  </macrodef>
	
  <c:set var="foo.bar" value="'some string (reference)'" />
  <property name="foo.bar" value="some string (property)'" />
	
  <taskdef name="name" classname="net.haefelingerit.flaka.Echo" />
}}}

Then we evaluate EL expressions in using Flaka's echo (again, we could have used any other task able to evaluate EL expressions):

{{{
<c:echo>
  #{name}             => same a reference.name
	  
  #{project.name}     => calling the getName() method on 
                         implicit object 'project'

  #{project['name']}  => same as project.name. Useful 
                         alternative for 'dotted' names.
		
	  # property
	  property.name          => #{property.name} 
      property['name']       => #{property['name']} 
	  # reference
	  reference.name         => #{reference.name}
	  var.name               => #{var.name}
	  # target
	  target.name            => #{target.name}
	  # taskdef
	  taskdef.name           => #{taskdef.name} 
	  # macrodef
	  macrodef.name          => #{macrodef.name1} 
	  # either taskdef or macrodef
	  task.name              => #{task.name}   
	  
	  # expenensive ..
	  project.properties.ant => #{project.properties.ant}
	  # better this way ..
      property.ant            => #{property.ant}
	  
	  # some math ..
	  value of 1+(37277 * 4777) = #{1+(37277 * 4777)}
		
	  # Handling of 'dotted' names 
	  # 
	  # queries getBar() on foo - not what we want
	  reference.foo.bar       => #{reference.foo.bar}
	  # NO: there is no 'foo' reference ..
	  reference[foo.bar]      => #{reference[foo.bar]}
	  # GOOD
	  reference['foo.bar']    => #{reference['foo.bar']}
	  # NO
	  foo.bar                 => #{foo.bar}
	  # NO (just evaluates to enclosed string)
	  'foo.bar'               => #{'foo.bar'}
		
      name    => #{empty project.name ? '(null)' : project.name}
	  basedir => #{project.baseDir.parent}
	  descr   => #{project.description}
</c:echo>
}}}



