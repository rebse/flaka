#summary Expression Language Details

= Introduction =

The Java Unified Expression Language (JSR-245) is a special purpose programming language offering a simple way of accessing data objects. The language has its roots in Java web applications for embedding expressions into web pages. While the expression language is part of the JSP specification, it does in no way depend on the JSP specification. To the contrary, the language can be made available in a variety of context.

One such context is Ant scripting. Ant makes it difficult to access data objects. For example, there is no way of querying the underlying data object for the base folder (the folder containing the build script). This is now easy:

{{{
<c:echo>
  Absolute path (as string) of base folder 
  #{project.baseDir.absolutePath}
  
  The parent folder
  #{project.baseDir.parent}
  
  The 'foo' property
  #{empty property.foo ? 'bar' : foo}

  #{property['ant.file']
</c:echo>
}}}

= Details =
== Enabling/Disabling EL ==

By default, EL is disabled. EL can be enabled by setting property _ant.el_ to any value. 


== Basic Usage ==

A EL expression is in general written as `#{..}` or `${..}`. The latter form is deprecated because this is Ant's way to query a property. Only if `${foo}` can't be resolved by Ant as property will `${foo}` be subject to EL evaluation. However, this only happens if 
  # property `foo` does not exists (as already mentioned)
  # a EL recognizing task is used
  # `${..}` and `#{..}` are not used in the same expression

EL expressions can only be used in Flaka tasks cause EL is not a standard Ant feature. For example thus, the following code will *NOT* work:
{{{
<echo>3*4=#{3*4}</echo>
-- 3*4=#{3*4}
}}}
Task `echo` is a standard Ant task and Ant is only able to resolve properties. One needs to use a task which _understands_ EL. Therefore, use `echo` provided by Flaka:
{{{
<c:echo>3*4=#{3*4}</c:echo>
-- 3*4=12
}}}
Flaka's `echo` is derived from standard `echo`. In addition some additional features are available. One feature, as demonstrated above, is the evaluation of embedded EL expressions. Other features of `echo` are described [Tasks#echo here].

== Implicit Objects ==

The following implicit objects are available by default:
  * *project* Ant's underlying project object. It can be used to query the default target, base folder and other things. If you want to query properties, references, targets, tasks, taskdefs, macrodefs, filters etc., use appropriate implicit object instead.
  * *property* Use this object to query project properties.
  * *var* A object containing all project references. 
  * *reference* Same as *var*
  * *target* Use this object to query a target
  * *taskdef* Query taskdefs
  * *macrodefs* Macros
  * *tasks*  Either taskdef or macrodef. Macros are specialized task and thus same the same namespace.
  * *filter*  A object containing all filters defined in this project.

== Example ==

The following larger example shows EL usage examples. Before starting, we define a couple of entities:
{{{
  <property name="name" value="PROPERTY name" />
  <c:set var="name" value=" REFERENCE name" />

  <target name="name" description="TARGET name" />

  <macrodef name="name1" description="NAME1 macro>
   <sequential />
  </macrodef>
	
  <c:set var="foo.bar" value="'some string (reference)'" />
  <property name="foo.bar" value="some string (property)'" />
	
  <taskdef name="name" classname="net.haefelingerit.flaka.Echo" />
}}}

Then we evaluate EL expressions in using Flaka's echo (again, we could have used any other task able to evaluate EL expressions):

{{{
<c:echo>
  #{name}             => same a reference.name
	  
  #{project.name}     => calling the getName() method on 
                         implicit object 'project'

  #{project['name']}  => same as project.name. Useful 
                         alternative for 'dotted' names.
		
	  # property
	  property.name          => #{property.name} 
      property['name']       => #{property['name']} 
	  # reference
	  reference.name         => #{reference.name}
	  var.name               => #{var.name}
	  # target
	  target.name            => #{target.name}
	  # taskdef
	  taskdef.name           => #{taskdef.name} 
	  # macrodef
	  macrodef.name          => #{macrodef.name1} 
	  # either taskdef or macrodef
	  task.name              => #{task.name}   
	  
	  # expenensive ..
	  project.properties.ant => #{project.properties.ant}
	  # better this way ..
      property.ant            => #{property.ant}
	  
	  # some math ..
	  value of 1+(37277 * 4777) = #{1+(37277 * 4777)}
		
	  # Handling of 'dotted' names 
	  # 
	  # queries getBar() on foo - not what we want
	  reference.foo.bar       => #{reference.foo.bar}
	  # NO: there is no 'foo' reference ..
	  reference[foo.bar]      => #{reference[foo.bar]}
	  # GOOD
	  reference['foo.bar']    => #{reference['foo.bar']}
	  # NO
	  foo.bar                 => #{foo.bar}
	  # NO (just evaluates to enclosed string)
	  'foo.bar'               => #{'foo.bar'}
		
      name    => #{empty project.name ? '(null)' : project.name}
	  basedir => #{project.baseDir.parent}
	  descr   => #{project.description}
</c:echo>
}}}


== File and Folders ==

Files and folders is Ant's bread and butter. A couple of properties are defined on file objects to simplify scripting (see below). Most important is however how to _get_ a file object in the first place. This is most easily done by using string property `tofile`:
{{{
  'myfolder'.tofile.isdir 
}}}
In this example of an EL expression, string `myfolder` is converted in a File object using property `tofile`. In addition, the so created object is checked whether it is a folder or not.

The following _properties_ are defined on File objects:
|| Property || Type || Meaning ||
|| `parent` || File || parent of file or folder as file object ||
|| `absolute`|| File || file or folder as absolute file object ||
|| `exists` || bool || check whether file or folder exists ||
|| `isfile` || bool || check whether a file ||
|| `isdir`  || bool || check whether a folder (directory) ||
|| `ishidden` || bool || check whether a hidden file or folder ||
|| `isread` || bool || check whether a file or folder is readable ||
|| `iswrite` || bool || check whether a file or folder is writable ||
|| `size`   || int  || number of bytes in a (existing) file; 0 otherwise||
|| `length` || int  || same as `size` ||
|| `mtime`  || Date || last modification date  ||
|| `list`   || File[] || array of files in folder ; otherwise `null` ||
|| `string` || String || file name as string object ||
|| `uri`    || URI  || file as URI object ||
|| `url`    || URL  || file as URL object ||
|| `delete` || bool || deletes the file or folder (true); false otherwise ||
|| `mkdir`  || bool || creates the folder (and intermediate) folders (true); false otherwise ||

== Functions ==

The following functions are defined:

|| Function || Type || Meaning ||
|| `size(object)`   || int  || Returns the object's size. The size of the object is given by the number of entities it contains. This is 0 (zero) for all primitive types. Otherwise the size is determined by an underlying `size()` method or `size` or `length` attribute of the object in question. || 